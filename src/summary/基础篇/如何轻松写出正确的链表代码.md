#### 理解指针或引用的含义
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
#### 利用哨兵简化实现难度 
针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。
* 引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。
*  哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。
#### 重点留意边界条件处理
* 如果链表为空时，代码是否能正常工作
* 如果链表只包含一个结点时，代码是否能正常工作
* 如果链表只包含两个结点时，代码是否能正常工作
* 代码逻辑在处理头结点和尾结点的时候，是否能正常工作

#### 刷题技巧

1. 设置哨兵(sentinel)节点
>一个附加在原链表最前面用来简化边界条件的附加节点，它的值域不存储任何东西，只是为了操作方便而引入。
* 合并链表——设置哨兵节点l1,返回l1.next即为合并链表。
* 删除链表首节点——常见的删除链表的操作是找到要删元素的前一个元素，假如我们记为 pre。我们通过：pre.Next = pre.Next.Next若是删除第一个元素的话，你就很难进行了，因为按道理来讲，此时第一个元素的前一个元素就是nil（空的），如果使用pre就会报错。那如果此时你设置了哨兵节点的话，此时的pre就是哨兵节点了。这样对于链表中的任何一个元素，你要删除都可以通过pre.Next=pre.Next.Next的方式来进行

